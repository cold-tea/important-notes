AGGREGATE FUNCTION -->>
	Return single value and works in a row.
	Eg: min, max, avg etc.
	
SUBQUERIES -->>
	Can be applied on SELECT, WHERE and FROM keywords
	Types
		Single Valued subqueries - Return single value (Can be applied on where = )
		Multiple Valued subqueries - Return multiple values (Can be applied on where in)
		Correlated subqueries - subqueries referencing the table or table alias from enclosing scope
		Multicolumn subqueries - subqueries returning more than one column
		Inline views - query used as a table providing the alias and performing further actions
		
INDEXES -->>
	Scanning table with millions of rows are often time consuming..
	Indexes are those schema objects which increments the performance of sql queries
	The most famous way of indexing is call B-Tree indexing. Where objects are stored in tree structure
	For say if index is create in salary column then the rows from value 1000 - 5000 will be stored in one leaf, 5000-10000 in another leaf and so on.
	Eg:
		CREATE INDEX index_name on table_name(column_name)
	Index referencing more than one column is called composite index.
	If multiple indexes are created for certain table then it will decrease the performance such that the DML operations performed should again recalculate where those value should be placed
	Explaing plan feature can be used to evaluate whether the indexes are being used or not during query execution

DATA DICTIONARY -->>
	USER_{name} - These view contains the info about the objects owned by the current connected user
	ALL_{name} - These view contains the info about the objects owned by the current user and those objects for which the user is given permission
	DBA_{name} - These view contains the info about all objects for all users
	DICT - This view has the metadata regarding all the views available as oracle data dictionary
	V${name} - These view has the dynamic info about various actions and are used primarily by adminstrators
				V$SESSION, V$SQLAREA, V$LOCK, V$INSTANCE etc.
				
TRANSACTIONS -->>
	COMMIT -
		Commit will commit the transactions made
		Rollback will rollback the changes made after last commit
		The record that is being modified in one session and not yet been committed will be locked such that other session cannot modify it
		There is another keyword called savepoint which marks the point of transaction and the rollback can be performed upto that point.
		syntax -
			(queries.......);   savepoint s1;  (queries.......);   rollback to s1;    -- this will rollback the transaction upto the savepoint s1
	
	
SEQUENCES -->>
	Database object used to generate unique objects
	syntax - 
		create sequence seq_name minvalue 1 maxvalue 99999 start with 1 increment by 1 cache 20
		cache will load the given integer into the memory to optimize the performance
	sequence_name.currval - current value in sequence, sequence.nextval - next value in sequence
	

IDENTITY COLUMNS -->>
	These column can be thought as built in columns with embedded sequence
	Types -
		GENERATED ALWAYS AS IDENTITY     -    If custom value is inserted then it will throw error
		GENERATED BY DEFAULT AS IDENTITY    - If custom value is inserted then it will accept .. the value is only inserted as default if not specified
		GENERATED BY DEFAULT AS IDENTITY (START WITH 100 INCREMENT BY 100) 
		
TRIGGERS -->>
	Triggers execute themselves at certain system event
	Types 
		DML
		DDL
		System Events (startup, shutdown, error messages)
		User Events (logon, logoff etc)
	
SYNONYMS -->>
	Synonyms are alternative names for database objects like table, views etc.
	syntax	
		create or replace synonym syn_name for (table_name/view_name etc).
		create or replace public synonym syn_name for (table_name/view_name etc).
		
		
PARTITIONING -->>
	Allows oracle data to be subdivided in small parts
	Tables are split horizontally
	Rows are divided and assigned to certain partitions based upon the condition on certain columns.
	Partitioning helps optimizer to find out in which partition the data reside and omit other partition from scanning.
	Partition vs Index
		If both are used then database optimizer might use index over partition.
	Types of table partitions
		List Partitioning -
			Here we have made four partitions. Values provides the condition analyzing which the records will be assigned to partition
			CREATE TABLE table_name 
			(columns.......)
			PARTITION BY LIST (column_name) (
				PARTITION parname_1 VALUES (...),
				PARTITION parname_2 VALUES (...),
				PARTITION parname_3 VALUES (...),
				PARTITION parname_4 VALUES (DEFAULT)    -- Value not matching any will be assigned here
			);
			
			Splitting existing partition parname_4 into two partitions
			ALTER TABLE table_name SPLIT PARTITION parname_4 VALUES (....)
			INTO (PARTITION parname_5, PARTITION parname_4);
		Range Partitioning -
			Here we have made four partitions. Values provides the condition analyzing which the records will be assigned to partition
			CREATE TABLE table_name 
			(columns.......)
			PARTITION BY RANGE (column_name) (
				PARTITION parname_1 VALUES LESS THAN (<something>),
				PARTITION parname_2 VALUES LESS THAN (<something>),
				PARTITION parname_3 VALUES LESS THAN (<something>),
				PARTITION parname_4 VALUES LESS THAN (<something>) 
			);
			
			Adding new partition
			ALTER TABLE table_name ADD PARTITION parname_5 VALUES LESS THAN (<something>)
		Hash Partitioning - 
			This method of partitioning is used when there is no specific way to partition the table.
			It just analyzes hash value and perform partitioning
			CREATE TABLE table_name 
			(columns......., PARTITION BY HASH (col_name)) PARTITIONS 4;
			
			ANALYZE TABLE table_name COMPUTE STATISTICS;   -- This will analyze the table and assign record to specific partition
			SELECT table_name, partition_name, num_rows FROM user_tab_partitions WHERE table_name = 'TABLE_NAME';
					-- This will list all partitions and provide info like number of rows etc.
		Interval Partitioning - 
		Composite Partitioning - 
		Automatic list Partitioning - 
		

		
------------------------------------------------------------ DATABASE ADMINSTRATION -------------------------------------
		
ARCHITECTURE -->>
	Made up of three parts - 
		Oracle instance
		Oracle database storage
		Oracle server processes (SPs)
		
		
ORACLE INSTANCE -->>
	Is loaded into the memory each time database starts (In memory nature)
	Contains shared memory caches (Shared pool, buffer cache, redo buffer etc.)
	Contains Oracle's background processes
	Instance will be removed from the memory once it is shut down (non persistent nature)
	
DATABASE STORAGE -->>
	This is the storage which contains oracle files to store the data
	This makes the physical oracle database
	Microsoft word and microsoft word file is analogous to oracle instance and oracle file
	Data storage is usually - Both are natively supported by oracle
		SAN -  Storage Area Netword (Accessed by fibre network)
		NAS -  Netword Attached Storage 
	Data can also be place in local disk (not recommended - single point of failure)	
		
		
SERVER PROCESSES (SPs) -->>
	Server processes are spawned when user is trying to connect to database.
	It's role -
		verify the syntax of sql query that the user is trying to execute
		it then read data from disk and also load it in the buffer cache
		
		
		
---------------ORACLE INSTALLATION PROCESS -----------------------------------------
......
............
.................

	After installation --
		Creating a database instance
			Goto dbhome/bin folder and run "netca"
			Go on and add the listener, default port of 1521 can be used as the listener's port
			After finishing it -
				run 'lsnrctl' command, after that 'status' command will show what listener is currently running
		Creating a database
			Goto dbhome/bin folder and run "dbca"
			While creating database select advanced mode and do accordingly
			For simplicity Create as container database is not checked, if checked then pluggable database will be created too if selected accordingly
			Oracle enterprise manager is the web interface provided through which we can manage our database as administrator
			During the setup of recovery area checking the archiving will archive the redo logs automatically
			Storage area can be setup which must be the secured one
			After filling up all the required details, the database creation and the instance creation step will begin.
		view /etc/oratab file for all the services running in the host
			orcl:/u01/app/oracle/product/12.2.0/dbhome_1:N, here N means the instance will not run automatically after reboot
		
		
		
---------------- ORACLE LINUX FIXING SWAP SIZE ----------------------------------------------------------------

	1 check what swap size
	#swapon –s
	Filename                                Type            Size    Used    Priority
	/dev/xvda3                              partition       2097144 0       -1
	  
	2 Create a file that you’ll use for swap with dd command with   as root
	dd if=/dev/zero of={/swapfile path} bs={size of swap}  count=1048576
	Example:-
	[root@localhost]#dd if=/dev/zero of=/home/swapfile bs=6048 count=1048576
	Note :- Above command will be create the 6Gb swapfile on /home location as  swapfile
	3 Set up a Linux swap area
	#mkswap /home/swapfile
	4: Enabling the swap file
	#swapon /home/swapfile
	#swapon –a
	5 status of add swap
	[root@myrem12c em12cBP1]# swapon -s
	Filename                                Type            Size    Used    Priority
	/dev/xvda3                              partition       2097144 0       -1
	/home/swapfile                          file            6097144 0       -2
	6 Update /etc/fstab   (this must to be done )
	#vi /etc/fstab
	/home/swapfile        none             swap   sw      0 0  
	Note  :- Add above line ending with  the file otherwise ones you restart the server swap partition not be mounted to the system

	Then retry the installation
		
		
		
---------------------- USEFUL LINUX COMMANDS (CENTOS) --------------------------------	
	
	wget http://get.geo.opera.com/pub/opera/linux/1216/opera-12.16-1860.x86_64.rpm
	lsnrctl status;	lsnrctl start;	lsnrctl stop;
	lsnrctl > status; lsnrctl > start; lsnrctl > stop;
	via sqlplus >
		start and stop the instance -
			alter system register;   >> force instance to connect to the listener automatically
			shutdown immediate;	shutdown abort; shutdown normal OR shutdown;     >> stopping the database instance
			startup;   >> startup mount and open
			startup unmount;   >> startup database to unmount state. Instance is up but not linked to the database
			startup mount;
			startup open;   >> ready to receive the connections
		parameters related -
			show parameter sga_target;
			show parameter sga_; >> list all the params with sg_ text as substring
			alter system set sga_target=1000m scope=memory/spfile/both;  >> memory -- cleared after restart, spfile -- stored in spfile reflects after restart, both -- both
			create pfile='/home/oracle/my_pfile.ora' from spfile;    >> this will copy all the parameters from spfile so that we can view it
		create user and permissions -
			create user user_name identified by password;   >> if connected then displays create session privilege error
			grant create session to user_name;    >> if create table is executed - insufficient privilege
			grant unlimited tablespace, create table to user_name; 
			drop user user_name;   >> only if the schema does not owns anything otherwise
			drop user user_name cascade;
			create role role_name;
			grant (roles.....) to role_name;
			grant role_name to user_name;
		data dictionary -
			v$logfile;    >> view all redo log files
			dba_data_files;    >> view data files, <file_name, tablespace_name> shows the datafile belonging to tablespace
			v$controlfile;		>> view control file.  >> if multiplexing is enabled then it will be stored in multiple places
			v$session;
			dba_tablespaces;
		troubleshoot using alert log -
			It contains all warnings, errors generated by oracle
			cd $ORACLE_BASE/diag/rdbms/orcl/orcl/trace   >> here alert_orcl.log
		storage - 
			tablespace is a collection of datafiles used as the storage
			dba_tablespaces -
				system - it is the tablespace where oracle data dictionary are stored.
			dba_data_files;    >> view data files, <file_name, tablespace_name> shows the datafile belonging to tablespace	
			create tablespace tbspc_name datafile '/mnt/san_storage/oradata/dfile01.dbf' size 20m autoextend on;
			drop tablespace tbspc_name including contents and datafiles;
		
		
		
		
		
	